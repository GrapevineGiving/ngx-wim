{"version":3,"sources":["ng://ngx-wim/lib/wim.service.ts","ng://ngx-wim/lib/wim.directive.ts","ng://ngx-wim/lib/wim.module.ts"],"names":["WHITESPACE_OR_LINE_BREAK","ALLOWED_LEFT_SURROUND","ALLOWED_RIGHT_SURROUND","WRAPPED_INLINE_MATCH","d","INLINE_DELIMITER_REGEX","RegExp","source","STRONG_REGEX","EM_REGEX","URL_REGEX","WimService","domSanitizer","this","escapeHtml","message","replace","prototype","toHtml","options","noEscape","x","preceeding","url","following","match","noSanitize","sanitize","SecurityContext","HTML","Injectable","args","providedIn","DomSanitizer","WimDirective","elementRef","renderer2","wimService","ngOnChanges","html","wim","setProperty","nativeElement","Directive","selector","ElementRef","Renderer2","Input","WimModule","NgModule","declarations","imports","exports","providers"],"mappings":"kWASMA,EAA2B,aAK3BC,EAAwB,6EACxBC,EAAyB,yFAGzBC,EAAoB,SAAGC,GAE3B,MAAA,KAAKA,EAEL,SAEQA,EAAC,wBAEcA,EAAC,UAEhBA,EAAC,SAGJA,GAMDC,EAAsB,SAAGD,GAC7B,OAAA,IAAIE,OACF,IACEN,EAAyBO,OACzBN,EAAsBM,OACtB,IACAJ,EAAqBC,GACrB,IACAF,EAAuBK,OACvBP,EAAyBO,OACzB,IACF,OAGEC,EAAeH,EAAuB,KACtCI,EAAWJ,EAAuB,KASlCK,EAAY,IAAIJ,OAEpB,+IAgBA,MAGFK,EAAA,WAIE,SAAAA,EAAoBC,GAAAC,KAAAD,aAAAA,SAELD,EAAAG,WAAf,SAA0BC,GAKxB,OADYA,EAETC,QAAQ,KAAM,QACdA,QAAQ,KAAM,QACdA,QAAQ,KAAM,UACdA,QAAQ,KAAM,WAGnBL,EAAAM,UAAAC,OAAA,SAAOH,EAAiBI,GAuBtB,YAvBsB,IAAAA,IAAAA,EAAA,IACjBA,EAAQC,WACXL,EAAUJ,EAAWG,WAAWC,IAgBlCA,GAHAA,GADAA,GAPAA,EAAUA,EAAQC,QAAQN,EAAS,SAAGW,EAAGC,EAAYC,EAAKC,GAGxD,OAAUF,EAAU,6BADPC,EAAIE,MAAM,6BAA+BF,EAAM,KAAOA,GACf,KAAKA,EAAG,OAAOC,KAInDR,QAAQR,EAAc,4BACtBQ,QAAQP,EAAU,oBAGlBO,QAAQ,MAAO,QAE5BG,EAAQO,aACXX,EAAUF,KAAKD,aAAae,SAASC,EAAAA,gBAAgBC,KAAMd,IAEtDA,uBAzCVe,EAAAA,WAAUC,KAAA,CAAC,CACVC,WAAY,oDAlFLC,EAAAA,mJAiFT,GClFA,IAAAC,EAAA,WAUE,SAAAA,EACUC,EACAC,EACAC,GAFAxB,KAAAsB,WAAAA,EACAtB,KAAAuB,UAAAA,EACAvB,KAAAwB,WAAAA,EAOZ,OAJEH,EAAAjB,UAAAqB,YAAA,eACQC,EAAO1B,KAAKwB,WAAWnB,OAAOL,KAAK2B,KAAO,IAChD3B,KAAKuB,UAAUK,YAAY5B,KAAKsB,WAAWO,cAAe,YAAaH,wBAd1EI,EAAAA,UAASZ,KAAA,CAAC,CACTa,SAAU,qDALQC,EAAAA,kBAA8BC,EAAAA,iBAEzCnC,kCAMNoC,EAAAA,MAAKhB,KAAA,CAAC,UAYTG,EApBA,GCAA,IAAAc,EAAA,WAKA,SAAAA,KAMwB,2BANvBC,EAAAA,SAAQlB,KAAA,CAAC,CACRmB,aAAc,CAAChB,GACfiB,QAAS,GACTC,QAAS,CAAClB,GACVmB,UAAW,CAAC1C,OAEUqC,EAXxB","sourcesContent":["import { Injectable, SecurityContext } from '@angular/core';\nimport { DomSanitizer } from '@angular/platform-browser';\n\nexport type WimOptions = {\n  noEscape?: boolean;\n  noSanitize?: boolean;\n};\n\n// Delimiters must be have whitespace or line-boundary around them.\nconst WHITESPACE_OR_LINE_BREAK = /(?:^|\\s|$)/;\n// Common surrounding characters can sit between the whitespace/line-boundary and the delimiter,\n// like quotes, parens, etc.\n// NOTE: Since HTML escaping may have been performed, need to match both literal and escaped chars.\n// TODO: _*nested*_ delimiter support is hacky. Bolster logic for it.\nconst ALLOWED_LEFT_SURROUND = /(?:\\(|'|&#039;|\"|&quot;|&#34;|â|&#8216;|â|&#8220;|_|<em>|\\*|<strong>){0,3}/;\nconst ALLOWED_RIGHT_SURROUND = /(?:\\)|'|&#039;|\"|&quot;|&#34;|â|&#8217;|â|&#8221;|_|<\\/em>|\\*|<\\/strong>|[,.?!:]){0,3}/;\n// Returns a regex matching the delimiters and the text they wrap. The wrapped text may not include\n// the delimiter.\nconst WRAPPED_INLINE_MATCH = d =>\n  // Open delimiter\n  `\\\\${d}` +\n  // Capture the text between delimiters.\n  `(` +\n  // Text between starts with non-whitespace.\n  `[^\\\\s${d}]` +\n  // Text between must not contain line-breaks or large-whitespace.\n  `(?:[^\\\\r\\\\n\\\\t\\\\f\\\\v${d}]*` +\n  // Text between ends with non-whitespace.\n  `[^\\\\s${d}])?` +\n  `)` +\n  // Close delimiter\n  `\\\\${d}`;\n\n// A full regex to match a delimiter. Capture groups:\n// 0: Text before opening delimiter.\n// 1: Text between delimiters.\n// 2: Text after closing delimiter.\nconst INLINE_DELIMITER_REGEX = d =>\n  new RegExp(\n    '(' +\n      WHITESPACE_OR_LINE_BREAK.source +\n      ALLOWED_LEFT_SURROUND.source +\n      ')' +\n      WRAPPED_INLINE_MATCH(d) +\n      '(' +\n      ALLOWED_RIGHT_SURROUND.source +\n      WHITESPACE_OR_LINE_BREAK.source +\n      ')',\n    'gm'\n  );\n\nconst STRONG_REGEX = INLINE_DELIMITER_REGEX('*');\nconst EM_REGEX = INLINE_DELIMITER_REGEX('_');\n\n// There is no general regex that can capture URLs-in-text perfectly. This is our good-enough\n// approximation.\n// TODO: Allow URL preceeded/followed by parenthesis, quotes, etc.\n// TODO: Allow IDN/Unicode domains.\nconst URL_REGEX_PATH_FINAL_CHARS = 'a-z0-9\\\\/\\\\-+&@#%=~_|$';\nconst URL_REGEX_FOLLOWING_CHARS = '?!:,.';\nconst URL_REGEX_PATH_CHARS = URL_REGEX_PATH_FINAL_CHARS + URL_REGEX_FOLLOWING_CHARS;\nconst URL_REGEX = new RegExp(\n  // Capture group $1: URL is preceeded by line-boundary or whitespace.\n  '(^|\\\\s)' +\n    // Capture group $2: the URL.\n    '(' +\n    // Optional protocols http://, https://, and ftp://\n    '(?:https?://|ftp://)?' +\n    // Domain plus any subdomains\n    '(?:[a-z0-9\\\\-]{1,63}\\\\.)+' +\n    // TLD\n    '[a-z]{1,63}' +\n    // Optional path. The final character's set is limited to prevent some ending punctuation.\n    // E.g., the final period of \"foo.com/bar.baz.\" shouldn't be included in the URL.\n    `(?:[${URL_REGEX_PATH_CHARS}]*[${URL_REGEX_PATH_FINAL_CHARS}])?` +\n    // End of URL capture group.\n    ')' +\n    // Capture group $3: URL is followed by line-boundary, whitespace, or \"following char.\"\n    `($|\\\\s|[${URL_REGEX_FOLLOWING_CHARS}])`,\n  'gi'\n);\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class WimService {\n  constructor(private domSanitizer: DomSanitizer) {}\n\n  private static escapeHtml(message: string): string {\n    // NOTE: Weird bug workaround. Angular complains `Expression form not supported` with some\n    // static methods. Either storing the param as a const before using it or adding `// @dynamic`\n    // to the class avoids it.\n    const msg = message;\n    return msg\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#039;');\n  }\n\n  toHtml(message: string, options: WimOptions = {}): string {\n    if (!options.noEscape) {\n      message = WimService.escapeHtml(message);\n    }\n\n    // Links!\n    // TODO: Prevent escaping link chars like &.\n    message = message.replace(URL_REGEX, (x, preceeding, url, following) => {\n      // If the URL doesn't have a protocol, prepend the relative protocol, '//'.\n      const href = url.match(/^((http|https|ftp):\\/\\/)/i) ? url : '//' + url;\n      return `${preceeding}<a target=\"_blank\" href=\"${href}\">${url}</a>${following}`;\n    });\n\n    // Inline delimiters like *bold* and _italic_.\n    message = message.replace(STRONG_REGEX, '$1<strong>$2</strong>$3');\n    message = message.replace(EM_REGEX, '$1<em>$2</em>$3');\n\n    // Breaks\n    message = message.replace(/\\n/g, '<br>');\n\n    if (!options.noSanitize) {\n      message = this.domSanitizer.sanitize(SecurityContext.HTML, message);\n    }\n    return message;\n  }\n}\n","import { Directive, ElementRef, Input, OnChanges, Renderer2 } from '@angular/core';\n\nimport { WimService } from './wim.service';\n\n@Directive({\n  selector: '[wim]',\n})\nexport class WimDirective implements OnChanges {\n  @Input('wim') wim: string;\n\n  constructor(\n    private elementRef: ElementRef,\n    private renderer2: Renderer2,\n    private wimService: WimService\n  ) {}\n\n  ngOnChanges() {\n    const html = this.wimService.toHtml(this.wim || '');\n    this.renderer2.setProperty(this.elementRef.nativeElement, 'innerHTML', html);\n  }\n}\n","import { NgModule } from '@angular/core';\n\nimport { WimDirective } from './wim.directive';\nimport { WimService } from './wim.service';\n\n@NgModule({\n  declarations: [WimDirective],\n  imports: [],\n  exports: [WimDirective],\n  providers: [WimService],\n})\nexport class WimModule {}\n"]}